import { useState, useEffect } from 'react';
import { useSelector } from 'react-redux';
import { Container, Row, Col, Modal, Alert } from 'react-bootstrap'; // Added Alert
import axios from 'axios';
// Relative imports within the same directory
import Sidebar from './Sidebar';
import InboxList from './InboxList';
import ConversationDetail from './ConversationDetail';
import ReplyModal from './ReplyModal';
import ComposeModal from './ComposeModal';
// Removed AiReplyBox import here, it's used within ConversationDetail

import './Dashboard.css'; // Assuming CSS is also here or adjust path

const Dashboard = () => {
  const [emails, setEmails] = useState([]);
  const [selectedConversation, setSelectedConversation] = useState(null);
  const [showDetailModal, setShowDetailModal] = useState(false); // Renamed for clarity
  const [showReplyModal, setShowReplyModal] = useState(false);
  const [replyMessage, setReplyMessage] = useState('');
  const [showComposeModal, setShowComposeModal] = useState(false);
  const [composeData, setComposeData] = useState({ receiver: '', subject: '', body: '' });
  const [error, setError] = useState(''); // General errors
  const [success, setSuccess] = useState(''); // General success messages
  const [composeAttachment, setComposeAttachment] = useState(null); // Renamed for clarity
  const [replyAttachment, setReplyAttachment] = useState(null);
  const [isUploading, setIsUploading] = useState(false); // For Cloudinary uploads
  const { userInfo } = useSelector((state) => state.auth);

  // --- AI State ---
  const [showAiPrompt, setShowAiPrompt] = useState(false); // Controls visibility in ConversationDetail
  const [aiPrompt, setAiPrompt] = useState(''); // User's prompt for the AI
  const [aiGeneratedReply, setAiGeneratedReply] = useState(''); // Text generated by AI
  const [isGeneratingAiReply, setIsGeneratingAiReply] = useState(false); // Loading state for AI call
  const [aiError, setAiError] = useState(''); // Specific errors from AI generation
  // --- End AI State ---

  // Fetch emails on initial load or when user changes
  useEffect(() => {
    const fetchEmails = async () => {
      if (!userInfo?.email) {
         console.log("User info not available yet for fetching emails.");
         return; // Don't fetch if email isn't available
      }
      try {
        setError(''); // Clear previous general errors
        const response = await axios.get(`/api/conversations/user/${userInfo.email}`);
        setEmails(response.data);
      } catch (err) {
        console.error('Failed to fetch emails:', err);
        setError(err.response?.data?.message || 'Failed to load your inbox.');
      }
    };
    fetchEmails();
  }, [userInfo]); // Rerun when userInfo object potentially changes

  // Reset AI state and selected conversation when the detail modal closes
  useEffect(() => {
    if (!showDetailModal) {
      setShowAiPrompt(false);
      setAiPrompt('');
      setAiGeneratedReply('');
      setIsGeneratingAiReply(false);
      setAiError('');
      setSelectedConversation(null); // Crucial to clear the selected convo
    }
  }, [showDetailModal]);

  // Handle clicking an email in the list
  const handleEmailClick = async (conversationId) => {
    setError(''); // Clear general errors
    setSuccess('');
    setAiError(''); // Clear previous AI errors
    setSelectedConversation(null); // Clear previous selection immediately
    setShowDetailModal(true); // Show modal (perhaps with a loading state initially)

    try {
      const response = await axios.get(`/api/conversations/${conversationId}`);
      setSelectedConversation(response.data);
      // Reset AI state specifically for this new conversation view
      setShowAiPrompt(false);
      setAiPrompt('');
      setAiGeneratedReply('');
      setIsGeneratingAiReply(false);
      setAiError('');
    } catch (err) {
      console.error('Failed to fetch conversation:', err);
      setError(err.response?.data?.message || 'Failed to load conversation details.');
      setShowDetailModal(false); // Close modal if fetch fails
    }
  };

  // --- Cloudinary Upload Helper ---
  const uploadToCloudinary = async (file) => {
    if (!file) return null; // Return null if no file

    const formData = new FormData();
    formData.append('file', file);
    formData.append('upload_preset', 'check123'); // Ensure this preset exists and allows unsigned uploads

    setIsUploading(true);
    try {
      const response = await axios.post(
        `https://api.cloudinary.com/v1_1/dx3y6lm0i/upload`, // Use your Cloudinary cloud name
        formData
      );
      setIsUploading(false);
      return response.data.secure_url; // Return the URL
    } catch (error) {
      console.error('Error uploading to Cloudinary:', error);
      console.error("Cloudinary error details:", error.response?.data);
      setIsUploading(false);
      throw new Error('Attachment upload failed. Please try again.'); // Throw error to be caught by caller
    }
  };


  // --- Manual Reply Logic ---
  // Opens the reply modal WITHOUT AI generation
  const handleManualReplyClick = () => {
      setError('');
      setSuccess('');
      setReplyMessage(''); // Start with empty message
      setReplyAttachment(null);
      setShowReplyModal(true);
      setShowAiPrompt(false); // Ensure AI box is hidden if user clicks manual reply
      // Do NOT clear aiGeneratedReply here, user might want to reference it visually
  };

  // Sends the actual reply (manual or AI-assisted)
  const handleSendReply = async () => {
     if (!selectedConversation || !replyMessage) {
         setError('Cannot send an empty reply.');
         return;
     }
     setError('');
     setSuccess('');

    try {
        // Upload attachment *before* sending the reply data
        let attachmentUrl = await uploadToCloudinary(replyAttachment); // Handles null attachment internally

        const { conversationId } = selectedConversation;
        const lastMessage = selectedConversation.messages[selectedConversation.messages.length - 1];
        const receiverEmail = lastMessage.sender === userInfo.email ? lastMessage.receiver : lastMessage.sender;
        const originalSubject = selectedConversation.messages[0].subject;
        const replySubject = originalSubject.toLowerCase().startsWith('re:') ? originalSubject : `Re: ${originalSubject}`;

        const replyData = {
            sender: userInfo.email,
            receiver: receiverEmail,
            subject: replySubject,
            body: replyMessage,
            attachment: attachmentUrl ? [attachmentUrl] : [], // Send array
        };

        await axios.post(`/api/conversations/${conversationId}/reply`, replyData);

        setSuccess('Reply sent successfully!');

        // Refresh the current conversation in the modal
         const updatedConvo = await axios.get(`/api/conversations/${conversationId}`);
         setSelectedConversation(updatedConvo.data);

        // Also refresh the main email list in the background
        const updatedEmails = await axios.get(`/api/conversations/user/${userInfo.email}`);
        setEmails(updatedEmails.data);


        // Close modal and reset state after a delay
        setTimeout(() => {
            setShowReplyModal(false);
            setReplyMessage('');
            setReplyAttachment(null);
            setSuccess('');
            // Decide whether to close the detail modal or not. Let's keep it open.
            // setShowDetailModal(false);
        }, 1500);

    } catch (err) {
        console.error('Failed to send reply:', err);
        // Display specific upload error or general send error
        setError(err.message || err.response?.data?.message || 'Failed to send reply.');
        setIsUploading(false); // Ensure upload indicator stops on error
    }
  };


  // --- Compose New Email Logic ---
  const handleComposeFileChange = (e) => {
    setComposeAttachment(e.target.files[0]);
  };

  const handleSendNewEmail = async () => {
    setError('');
    setSuccess('');
    if (!composeData.receiver || !composeData.subject || !composeData.body) {
      setError('Receiver, Subject, and Body are required for a new email.');
      return;
    }

    try {
      // Upload attachment first
      let attachmentUrl = await uploadToCloudinary(composeAttachment); // Handles null

      const emailData = {
        sender: userInfo.email,
        receiver: composeData.receiver,
        subject: composeData.subject,
        body: composeData.body,
        attachment: attachmentUrl ? [attachmentUrl] : [],
      };

      const response = await axios.post('/api/conversations', emailData);

      if (response.status === 201) {
        setSuccess('Email sent successfully!');
        // Refresh email list
        const updatedResponse = await axios.get(`/api/conversations/user/${userInfo.email}`);
        setEmails(updatedResponse.data);
        // Reset form and close modal
        setComposeData({ receiver: '', subject: '', body: '' });
        setComposeAttachment(null);
        setTimeout(() => {
          setShowComposeModal(false);
          setSuccess('');
        }, 1500);
      }
    } catch (err) {
      console.error('Failed to send email:', err);
      // Display specific upload error or general send error
      setError(err.message || err.response?.data?.message || 'Failed to send email.');
       setIsUploading(false); // Ensure upload indicator stops on error
    }
  };


  // --- AI Generation Logic ---
  const handleGenerateAiReply = async () => {
    if (!selectedConversation || !aiPrompt) return;

    setAiError(''); // Clear previous AI error
    setAiGeneratedReply(''); // Clear previous AI result
    setIsGeneratingAiReply(true); // Show loading

    
    try {
      const { conversationId } = selectedConversation;
      const apiUrl = `/api/conversations/${conversationId}/generate`; // Construct the URL

      // --- Add these logs ---
      console.log('[AI GEN REQ] Conversation ID:', conversationId);
      console.log('[AI GEN REQ] Target URL:', apiUrl);
      console.log('[AI GEN REQ] Prompt:', aiPrompt);
      // --- End logs ---

      const response = await axios.post(
        apiUrl, // Use the constructed URL
        { prompt: aiPrompt }
      );


      if (response.data && response.data.generated_text) {
        setAiGeneratedReply(response.data.generated_text);
      } else {
        // Handle cases where the ML service might return an error structure differently
        throw new Error(response.data?.error || "AI service returned an unexpected response.");
      }

    } catch (err) {
      console.error('Failed to generate AI reply:', err);
      // Extract error message preferrably from response, otherwise use generic message
      const errorMsg = err.response?.data?.message // Error from Node backend wrapper
                       || err.response?.data?.ai_service_error?.error // Error directly from Python service (if forwarded)
                       || err.message // Network or other errors
                       || 'Could not get AI suggestion.';
      setAiError(errorMsg);
    } finally {
      setIsGeneratingAiReply(false); // Hide loading
    }
  };


  // --- Use AI Reply Logic ---
  // Called when "Use this Reply" button is clicked in AiReplyBox
  const handleUseAiReply = (generatedText) => {
    setReplyMessage(generatedText); // Set the content for the ReplyModal
    setShowAiPrompt(false); // Hide the AI section
    setShowReplyModal(true); // SHOW the standard ReplyModal for final review/send
    // Clear AI prompt/result *after* transferring the text
    setAiPrompt('');
    // Keep aiGeneratedReply for a bit? Or clear it? Let's clear it.
    // setAiGeneratedReply('');
    setAiError('');
  };

  // --- Reply Modal Attachment Handler ---
  const handleReplyFileChange = (e) => {
    setReplyAttachment(e.target.files[0]);
  };


  // --- Render Logic ---
  return (
    <div className="dashboard-container">
      <Container fluid>
        <Row>
          <Col md={3} className="sidebar-container">
            <Sidebar onCompose={() => {
                setError('');
                setSuccess('');
                setComposeData({ receiver: '', subject: '', body: '' }); // Reset form
                setComposeAttachment(null);
                setShowComposeModal(true);
            }} />
          </Col>
          <Col md={9} className="content-container">
            <h2 className="inbox-title">Inbox</h2>
            {/* Display general errors only when no modal is actively showing its own errors */}
            {error && !showComposeModal && !showReplyModal && !showDetailModal && <Alert variant="danger">{error}</Alert>}
            <InboxList
                emails={emails}
                onEmailClick={handleEmailClick}
                userEmail={userInfo?.email || ''}
            />
          </Col>
        </Row>
      </Container>

      {/* Modal for Conversation Details */}
      <Modal contentClassName="modal-height" show={showDetailModal} onHide={() => setShowDetailModal(false)} size="xl" centered backdrop="static"> {/* static backdrop */}
        <Modal.Header closeButton>
          <Modal.Title>Conversation</Modal.Title>
        </Modal.Header>
        <Modal.Body>
          {/* Show loading or error specific to detail view */}
          {!selectedConversation && !error && <p>Loading conversation...</p> }
          {error && showDetailModal && <Alert variant="danger">{error}</Alert>}

          {selectedConversation && (
            <ConversationDetail
              conversation={selectedConversation}
              onReplyClick={handleManualReplyClick} // Button for manual reply modal
              // --- Pass AI state and handlers down ---
              showAiPrompt={showAiPrompt}
              onToggleAiPrompt={() => setShowAiPrompt(!showAiPrompt)} // Toggle visibility
              aiPrompt={aiPrompt}
              setAiPrompt={setAiPrompt} // Allow AiReplyBox to update prompt state
              onGenerateAiReply={handleGenerateAiReply} // Trigger AI generation
              isGeneratingAiReply={isGeneratingAiReply} // Pass loading state
              aiGeneratedReply={aiGeneratedReply} // Pass generated text
              aiError={aiError} // Pass AI-specific errors
              onUseAiReply={handleUseAiReply} // Pass handler for "Use this Reply" button
              // --- End AI props ---
            />
          )}
        </Modal.Body>
         {/* Footer might not be needed if actions are inside ConversationDetail */}
      </Modal>

      {/* Modal for Manual/Final Reply */}
      <ReplyModal
        show={showReplyModal}
        onHide={() => setShowReplyModal(false)}
        message={replyMessage}
        setMessage={setReplyMessage}
        onSend={handleSendReply}
        error={error} // Show general send/upload errors here
        success={success}
        setAttachment={handleReplyFileChange} // Handler for reply attachment input
        isSending={isUploading} // Pass the uploading state for UI feedback
      />

      {/* Modal for Composing New Email */}
      <ComposeModal
        show={showComposeModal}
        onHide={() => { setShowComposeModal(false); setError(''); setSuccess(''); }}
        formData={composeData}
        setFormData={setComposeData}
        onSend={handleSendNewEmail}
        error={error} // Show general send/upload errors here
        success={success}
        setAttachment={handleComposeFileChange} // Handler for compose attachment input
        isSending={isUploading} // Pass the uploading state
      />
    </div>
  );
};

export default Dashboard;